import {
  boolean,
  index,
  integer,
  jsonb,
  pgEnum,
  pgTable,
  real,
  serial,
  text,
  timestamp,
  unique,
  varchar,
} from "drizzle-orm/pg-core";

// ============================================================================
// Enums
// ============================================================================

export const extractionStatusEnum = pgEnum("extraction_status", [
  "pending",
  "in_progress",
  "completed",
  "failed",
]);

export type ExtractionStatus = (typeof extractionStatusEnum.enumValues)[number];

export const analysisStatusEnum = pgEnum("analysis_status", [
  "pending",
  "streaming",
  "completed",
  "failed",
]);

export type AnalysisStatus = (typeof analysisStatusEnum.enumValues)[number];

export const framePositionEnum = pgEnum("frame_position", ["first", "last"]);

export type FramePosition = (typeof framePositionEnum.enumValues)[number];

export const samenessEnum = pgEnum("sameness", ["same", "different"]);

export type Sameness = (typeof samenessEnum.enumValues)[number];

// ============================================================================
// Core Video Tables
// ============================================================================

export const channels = pgTable("channels", {
  channelId: varchar("channel_id", { length: 64 }).primaryKey(),
  channelName: text("channel_name").notNull(),
});

export const videos = pgTable(
  "videos",
  {
    videoId: varchar("video_id", { length: 32 }).primaryKey(),
    url: text("url").notNull(),
    title: text("title").notNull(),
    publishedAt: timestamp("published_at", { withTimezone: true }),
    channelId: varchar("channel_id", { length: 64 })
      .notNull()
      .references(() => channels.channelId, {
        onDelete: "cascade",
        onUpdate: "cascade",
      }),
  },
  (table) => [index("videos_channel_id_idx").on(table.channelId)],
);

const videoIdColumn = () =>
  varchar("video_id", { length: 32 })
    .notNull()
    .references(() => videos.videoId, { onDelete: "cascade" });

export const scrapTranscriptV1 = pgTable(
  "scrap_transcript_v1",
  {
    id: serial("id").primaryKey(),
    videoId: videoIdColumn(),
    channelId: varchar("channel_id", { length: 64 })
      .notNull()
      .references(() => channels.channelId, { onDelete: "cascade" }),
    description: text("description"),
    subscriberCount: integer("subscriber_count"),
    viewCount: integer("view_count"),
    likeCount: integer("like_count"),
    durationSeconds: integer("duration_seconds"),
    isAutoGenerated: boolean("is_auto_generated"),
    thumbnail: text("thumbnail"),
    transcript: jsonb("transcript"),
    createdAt: timestamp("created_at").defaultNow(),
  },
  (table) => [unique("unique_video_transcript").on(table.videoId)],
);

export type ScrapedTranscript = typeof scrapTranscriptV1.$inferSelect;
export type NewScrapedTranscript = typeof scrapTranscriptV1.$inferInsert;

export const videoAnalysisRuns = pgTable("video_analysis_runs", {
  videoId: videoIdColumn().primaryKey(),
  result: jsonb("result").$type<Record<string, unknown>>(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export type VideoAnalysisRun = typeof videoAnalysisRuns.$inferSelect;
export type NewVideoAnalysisRun = typeof videoAnalysisRuns.$inferInsert;

export const videoAnalysisWorkflowIds = pgTable(
  "video_analysis_workflow_ids",
  {
    videoId: videoIdColumn().primaryKey(),
    workflowId: varchar("workflow_id", { length: 100 }).notNull(),
    createdAt: timestamp("created_at").defaultNow().notNull(),
  },
  (table) => [
    index("video_analysis_workflow_ids_video_id_idx").on(table.workflowId),
  ],
);

export type VideoAnalysisWorkflowId =
  typeof videoAnalysisWorkflowIds.$inferSelect;
export type NewVideoAnalysisWorkflowId =
  typeof videoAnalysisWorkflowIds.$inferInsert;

export const superAnalysisRuns = pgTable("super_analysis_runs", {
  videoId: videoIdColumn().primaryKey(),
  result: text("result"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export type SuperAnalysisRun = typeof superAnalysisRuns.$inferSelect;
export type NewSuperAnalysisRun = typeof superAnalysisRuns.$inferInsert;

export const superAnalysisWorkflowIds = pgTable(
  "super_analysis_workflow_ids",
  {
    videoId: videoIdColumn().primaryKey(),
    workflowId: varchar("workflow_id", { length: 100 }).notNull(),
    createdAt: timestamp("created_at").defaultNow().notNull(),
  },
  (table) => [
    index("super_analysis_workflow_ids_video_id_idx").on(table.workflowId),
  ],
);

export type SuperAnalysisWorkflowId =
  typeof superAnalysisWorkflowIds.$inferSelect;
export type NewSuperAnalysisWorkflowId =
  typeof superAnalysisWorkflowIds.$inferInsert;

// ============================================================================
// Slides Tables
// ============================================================================

export const videoSlideExtractions = pgTable(
  "video_slide_extractions",
  {
    id: serial("id").primaryKey(),
    videoId: videoIdColumn(),
    status: extractionStatusEnum("status").notNull().default("pending"),
    runId: varchar("run_id", { length: 100 }), // Workflow run ID for resumption
    totalSlides: integer("total_slides"),
    errorMessage: text("error_message"),
    createdAt: timestamp("created_at").defaultNow().notNull(),
  },
  (table) => [
    index("video_slide_extractions_video_idx").on(table.videoId),
    unique("video_slide_extractions_video_unique").on(table.videoId),
  ],
);

export type VideoSlideExtraction = typeof videoSlideExtractions.$inferSelect;

export const videoSlides = pgTable(
  "video_slides",
  {
    id: serial("id").primaryKey(),
    videoId: videoIdColumn(),
    slideNumber: integer("slide_index").notNull(),

    // Timing
    startTime: real("start_time").notNull(), // seconds with floating point precision
    endTime: real("end_time").notNull(),
    duration: real("duration").notNull(),

    // First frame data
    firstFrameImageUrl: text("first_frame_image_url"),
    firstFrameIsDuplicate: boolean("first_frame_is_duplicate")
      .default(false)
      .notNull(),
    firstFrameDuplicateOfSlideNumber: integer(
      "first_frame_duplicate_of_segment_id",
    ),
    firstFrameDuplicateOfFramePosition: framePositionEnum(
      "first_frame_duplicate_of_frame_position",
    ),

    // Last frame data
    lastFrameImageUrl: text("last_frame_image_url"),
    lastFrameIsDuplicate: boolean("last_frame_is_duplicate")
      .default(false)
      .notNull(),
    lastFrameDuplicateOfSlideNumber: integer(
      "last_frame_duplicate_of_segment_id",
    ),
    lastFrameDuplicateOfFramePosition: framePositionEnum(
      "last_frame_duplicate_of_frame_position",
    ),

    createdAt: timestamp("created_at").defaultNow().notNull(),
  },
  (table) => [
    index("video_slides_video_idx").on(table.videoId),
    unique("video_slides_video_index").on(table.videoId, table.slideNumber),
  ],
);

export type VideoSlide = typeof videoSlides.$inferSelect;
export type NewVideoSlide = typeof videoSlides.$inferInsert;

/**
 * Feedback on individual slides - validation of frame annotations and sameness
 */
export const slideFeedback = pgTable(
  "slide_feedback",
  {
    id: serial("id").primaryKey(),
    videoId: videoIdColumn(),
    slideNumber: integer("slide_index").notNull(),

    // Frame-level content assessment
    firstFrameHasUsefulContent: boolean("first_frame_has_useful_content"),
    lastFrameHasUsefulContent: boolean("last_frame_has_useful_content"),

    // Sameness feedback
    framesSameness: samenessEnum("frames_sameness"),

    // Frame selection - whether individual frames are picked for export
    isFirstFramePicked: boolean("is_first_frame_picked")
      .default(false)
      .notNull(),
    isLastFramePicked: boolean("is_last_frame_picked").default(false).notNull(),

    createdAt: timestamp("created_at").defaultNow().notNull(),
  },
  (table) => [
    index("slide_feedback_video_idx").on(table.videoId),
    unique("slide_feedback_video_slide").on(table.videoId, table.slideNumber),
  ],
);

export type SlideFeedback = typeof slideFeedback.$inferSelect;
export type NewSlideFeedback = typeof slideFeedback.$inferInsert;

// ============================================================================
// Slide Analysis Tables
// ============================================================================

/**
 * Stores AI-generated markdown analysis for individual slide frames
 */
export const slideAnalysisResults = pgTable(
  "slide_analysis_results",
  {
    id: serial("id").primaryKey(),
    videoId: videoIdColumn(),
    slideNumber: integer("slide_number").notNull(),
    framePosition: framePositionEnum("frame_position").notNull(),
    markdownContent: text("markdown_content").notNull(),
    createdAt: timestamp("created_at").defaultNow().notNull(),
  },
  (table) => [
    index("slide_analysis_results_video_idx").on(table.videoId),
    unique("slide_analysis_results_video_slide_frame").on(
      table.videoId,
      table.slideNumber,
      table.framePosition,
    ),
  ],
);

export type SlideAnalysisResult = typeof slideAnalysisResults.$inferSelect;
export type NewSlideAnalysisResult = typeof slideAnalysisResults.$inferInsert;
