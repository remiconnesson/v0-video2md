/*
 * Workaround for https://github.com/vercel/workflow/issues/618 where `await run.returnValue` hangs infinitely in production when using Vercel workflow with RSC.

Moved the fetch-and-save-transcript logic from the workflow directly into a lib utility function that can be called synchronously from RSC.

Tried to reuse the workflow steps directly but stumbled upon another issue https://github.com/vercel/workflow/issues/630, where you can't call a step function outside of a workflow if that functions uses dependencies not marked with "use step"
*/
import { z } from "zod";
import { getVideoWithTranscript } from "@/db/queries";
import {
  saveTranscriptToDb,
  type TranscriptResult,
} from "@/db/save-transcript";
import { formatTranscriptForLLM } from "./transcript-format";

// ============================================================================
// Transcript Schema (for validation)
// ============================================================================

const TranscriptSegmentSchema = z.object({
  start: z.number(),
  end: z.number(),
  text: z.string(),
});
type TranscriptSegment = z.infer<typeof TranscriptSegmentSchema>;

function validateTranscriptStructure(data: unknown): TranscriptSegment[] {
  return z.array(TranscriptSegmentSchema).parse(data);
}

// ============================================================================
// Transcript Data Interface
// ============================================================================

export interface TranscriptData {
  videoId: string;
  title: string;
  channelName: string;
  description: string | null;
  transcript: string;
}

// ============================================================================
// Apify Schema (for validating API response)
// ============================================================================

const ApifyTranscriptResponseSchema = z.object({
  video_id: z.string(),
  url: z.string(),
  title: z.string(),
  published_at: z.string(),
  channel_id: z.string(),
  channel_name: z.string(),
  description: z.string(),
  subscriber_count: z.number(),
  view_count: z.number(),
  like_count: z.number(),
  duration_seconds: z.number(),
  is_auto_generated: z.boolean(),
  thumbnail: z.string(),
  transcript: z.array(TranscriptSegmentSchema),
});

function transformApifyResponse(
  data: z.infer<typeof ApifyTranscriptResponseSchema>,
): TranscriptResult {
  return {
    videoId: data.video_id,
    url: data.url,
    title: data.title,
    date: data.published_at,
    channelId: data.channel_id,
    channelName: data.channel_name,
    description: data.description,
    numberOfSubscribers: data.subscriber_count,
    viewCount: data.view_count,
    likes: data.like_count,
    duration: formatDurationFromSeconds(data.duration_seconds),
    isAutoGenerated: data.is_auto_generated,
    thumbnailUrl: data.thumbnail,
    transcript: data.transcript,
  };
}

function formatDurationFromSeconds(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);

  if (hours > 0) {
    return `${hours}:${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
  }
  return `${mins}:${secs.toString().padStart(2, "0")}`;
}

// ============================================================================
// DB Functions
// ============================================================================

async function getTranscriptDataFromDb(
  videoId: string,
): Promise<TranscriptData | null> {
  const transcriptRow = await getVideoWithTranscript(videoId);

  if (!transcriptRow) {
    return null;
  }

  const transcriptSegments = validateTranscriptStructure(
    transcriptRow.transcript,
  );

  return {
    ...transcriptRow,
    transcript: formatTranscriptForLLM(transcriptSegments),
  };
}

// ============================================================================
// Apify Functions
// ============================================================================

async function fetchYoutubeTranscriptFromApify(
  videoId: string,
): Promise<TranscriptResult> {
  const { ApifyClient } = await import("apify-client");

  if (!process.env.APIFY_API_TOKEN) {
    throw new Error("APIFY_API_TOKEN is not defined");
  }

  const client = new ApifyClient({ token: process.env.APIFY_API_TOKEN });
  const actorRun = await client.actor("Uwpce1RSXlrzF6WBA").call({
    youtube_url: `https://www.youtube.com/watch?v=${videoId}`,
  });

  const { items } = await client.dataset(actorRun.defaultDatasetId).listItems();
  const rawApiResponse = items[0];

  if (!rawApiResponse) {
    throw new Error(`No results found for video ID: ${videoId}`);
  }

  const parseResult = ApifyTranscriptResponseSchema.safeParse(rawApiResponse);

  if (!parseResult.success) {
    console.error(
      "[Apify] Validation failed. Raw response keys:",
      Object.keys(rawApiResponse),
    );
    console.error(
      "[Apify] Validation errors:",
      JSON.stringify(parseResult.error.format(), null, 2),
    );
    throw new Error(
      `Invalid Apify response: ${parseResult.error.issues.map((i) => `${i.path.join(".")}: ${i.message}`).join(", ")}`,
    );
  }

  return transformApifyResponse(parseResult.data);
}

// ============================================================================
// Main Function: Fetch and Save Transcript
// ============================================================================

/**
 * Fetches transcript data for a YouTube video.
 * First checks the database for cached data, if not found fetches from Apify and saves.
 *
 * This is a direct implementation that doesn't use the Vercel workflow system,
 * working around the issue where `await run.returnValue` hangs in production RSC.
 * See: https://github.com/vercel/workflow/issues/618
 */
export async function fetchAndSaveTranscript(
  videoId: string,
): Promise<TranscriptData> {
  console.log("[fetchAndSaveTranscript] 1. Start, videoId:", videoId);

  const cachedTranscriptData = await getTranscriptDataFromDb(videoId);
  console.log("[fetchAndSaveTranscript] 2. Cached:", !!cachedTranscriptData);

  if (
    cachedTranscriptData &&
    cachedTranscriptData.title &&
    cachedTranscriptData.channelName
  ) {
    return cachedTranscriptData;
  }

  if (cachedTranscriptData) {
    console.log(
      "[fetchAndSaveTranscript] Cached data found but incomplete (missing title or channel). Re-fetching...",
    );
  }

  console.log("[fetchAndSaveTranscript] 3. Fetching from Apify...");
  const fetchedResult = await fetchYoutubeTranscriptFromApify(videoId);
  console.log("[fetchAndSaveTranscript] 4. Saving to DB...");
  await saveTranscriptToDb(fetchedResult);

  // biome-ignore lint/style/noNonNullAssertion: we know the transcript data exists after saving
  const transcriptData = (await getTranscriptDataFromDb(videoId))!;

  console.log("[fetchAndSaveTranscript] 5. Returning:", transcriptData.title);
  return transcriptData;
}
