/*
 * Workaround for https://github.com/vercel/workflow/issues/618 where `await run.returnValue` hangs infinitely in production when using Vercel workflow with RSC.

Moved the fetch-and-save-transcript logic from the workflow directly into a lib utility function that can be called synchronously from RSC.

Tried to reuse the workflow steps directly but stumbled upon another issue https://github.com/vercel/workflow/issues/630, where you can't call a step function outside of a workflow if that functions uses dependencies not marked with "use step"
*/
import { z } from "zod";
import { getVideoWithTranscript } from "@/db/queries";
import {
  saveTranscriptToDb,
  type TranscriptResult,
} from "@/db/save-transcript";
import { formatTranscriptForLLM } from "./transcript-format";

// ============================================================================
// Transcript Schema (for validation)
// ============================================================================

const TranscriptSegmentSchema = z.object({
  start: z.number(),
  end: z.number(),
  text: z.string(),
});
type TranscriptSegment = z.infer<typeof TranscriptSegmentSchema>;

function validateTranscriptStructure(data: unknown): TranscriptSegment[] {
  return z.array(TranscriptSegmentSchema).parse(data);
}

// ============================================================================
// Transcript Data Interface
// ============================================================================

export interface TranscriptData {
  videoId: string;
  title: string;
  channelName: string;
  description: string | null;
  transcript: string;
}

// ============================================================================
// Apify Schema (for validating API response)
// ============================================================================

const ApifyTranscriptResponseSchema = z.object({
  video_id: z.string(),
  url: z.string(),
  title: z.string(),
  published_at: z.string(),
  channel_id: z.string(),
  channel_name: z.string(),
  description: z.string(),
  subscriber_count: z.number(),
  view_count: z.number(),
  like_count: z.number(),
  duration_seconds: z.number(),
  is_auto_generated: z.boolean(),
  thumbnail: z.string(),
  transcript: z.array(TranscriptSegmentSchema),
});

function transformApifyResponse(
  data: z.infer<typeof ApifyTranscriptResponseSchema>,
): TranscriptResult {
  return {
    videoId: data.video_id,
    url: data.url,
    title: data.title,
    date: data.published_at,
    channelId: data.channel_id,
    channelName: data.channel_name,
    description: data.description,
    numberOfSubscribers: data.subscriber_count,
    viewCount: data.view_count,
    likes: data.like_count,
    duration: formatDurationFromSeconds(data.duration_seconds),
    isAutoGenerated: data.is_auto_generated,
    thumbnailUrl: data.thumbnail,
    transcript: data.transcript,
  };
}

function formatDurationFromSeconds(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);

  if (hours > 0) {
    return `${hours}:${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
  }
  return `${mins}:${secs.toString().padStart(2, "0")}`;
}

// ============================================================================
// DB Functions
// ============================================================================

async function getTranscriptDataFromDb(
  videoId: string,
): Promise<TranscriptData | null> {
  const transcriptRow = await getVideoWithTranscript(videoId);

  if (!transcriptRow) {
    return null;
  }

  const transcriptSegments = validateTranscriptStructure(
    transcriptRow.transcript,
  );

  return {
    ...transcriptRow,
    transcript: formatTranscriptForLLM(transcriptSegments),
  };
}

// ============================================================================
// Apify Functions
// ============================================================================

async function fetchYoutubeTranscriptFromApify(
  videoId: string,
): Promise<TranscriptResult> {
  const { ApifyClient } = await import("apify-client");

  if (!process.env.APIFY_API_TOKEN) {
    throw new Error("APIFY_API_TOKEN is not defined");
  }

  const client = new ApifyClient({ token: process.env.APIFY_API_TOKEN });

  // Use start() instead of call() to avoid blocking if we were in a workflow context,
  // but since this is a library function running in a standard server environment (e.g. Server Action),
  // we still have a timeout (usually 15-60s).
  // If we are in a Vercel Function, we might still time out if the actor takes too long.
  // However, unlike Workflows, we can't easily poll with sleep/suspension efficiently without blocking.
  // So for this synchronous-ish library function, we might still be stuck with blocking call or implement a polling loop.
  // Given this is a "workaround" function, maybe we should also use polling here to at least handle the 'wait' properly?
  // But `client.actor(...).call()` does exactly that: starts and waits.

  // The issue with `call()` is that it blocks the event loop while waiting for the network response from Apify which says "run finished".
  // `apify-client`'s `call` uses polling internally (or long polling).

  // If the user's issue "500ed without logs" happens here too, it's because the Vercel function timed out.
  // But this library function is likely used in contexts where maybe the timeout is different or it's a backup.
  // The user's screenshot showed a workflow failure.

  // I will keep `call` here but maybe add better error handling?
  // Actually, if I change it to `start` + polling, I can add logs.

  console.log(`[Apify] Starting actor for video ${videoId}...`);
  const actorRun = await client.actor("Uwpce1RSXlrzF6WBA").start({
    youtube_url: `https://www.youtube.com/watch?v=${videoId}`,
  });

  console.log(
    `[Apify] Actor started, runId: ${actorRun.id}. Waiting for completion...`,
  );

  // Poll for completion
  let run = actorRun;
  while (run.status === "READY" || run.status === "RUNNING") {
    await new Promise((resolve) => setTimeout(resolve, 5000)); // 5s wait
    run = (await client.run(run.id).get()) as typeof actorRun; // cast to avoid null check noise, get() returns Run | undefined but usually Run
    if (!run) throw new Error(`Apify run ${actorRun.id} disappeared`);
  }

  if (run.status !== "SUCCEEDED") {
    throw new Error(`Apify run failed with status: ${run.status}`);
  }

  console.log(`[Apify] Actor finished. Fetching results...`);

  const { items } = await client.dataset(run.defaultDatasetId).listItems();
  const rawApiResponse = items[0];

  if (!rawApiResponse) {
    throw new Error(`No results found for video ID: ${videoId}`);
  }

  const parseResult = ApifyTranscriptResponseSchema.safeParse(rawApiResponse);

  if (!parseResult.success) {
    console.error(
      "[Apify] Validation failed. Raw response keys:",
      Object.keys(rawApiResponse),
    );
    console.error(
      "[Apify] Validation errors:",
      JSON.stringify(parseResult.error.format(), null, 2),
    );
    throw new Error(
      `Invalid Apify response: ${parseResult.error.issues.map((i) => `${i.path.join(".")}: ${i.message}`).join(", ")}`,
    );
  }

  return transformApifyResponse(parseResult.data);
}

// ============================================================================
// Main Function: Fetch and Save Transcript
// ============================================================================

/**
 * Fetches transcript data for a YouTube video.
 * First checks the database for cached data, if not found fetches from Apify and saves.
 *
 * This is a direct implementation that doesn't use the Vercel workflow system,
 * working around the issue where `await run.returnValue` hangs in production RSC.
 * See: https://github.com/vercel/workflow/issues/618
 */
export async function fetchAndSaveTranscript(
  videoId: string,
): Promise<TranscriptData> {
  console.log("[fetchAndSaveTranscript] 1. Start, videoId:", videoId);

  const cachedTranscriptData = await getTranscriptDataFromDb(videoId);
  console.log("[fetchAndSaveTranscript] 2. Cached:", !!cachedTranscriptData);

  if (cachedTranscriptData?.title && cachedTranscriptData.channelName) {
    return cachedTranscriptData;
  }

  if (cachedTranscriptData) {
    console.log(
      "[fetchAndSaveTranscript] Cached data found but incomplete (missing title or channel). Re-fetching...",
    );
  }

  console.log("[fetchAndSaveTranscript] 3. Fetching from Apify...");
  const fetchedResult = await fetchYoutubeTranscriptFromApify(videoId);
  console.log("[fetchAndSaveTranscript] 4. Saving to DB...");
  await saveTranscriptToDb(fetchedResult);

  // biome-ignore lint/style/noNonNullAssertion: we know the transcript data exists after saving
  const transcriptData = (await getTranscriptDataFromDb(videoId))!;

  console.log("[fetchAndSaveTranscript] 5. Returning:", transcriptData.title);
  return transcriptData;
}
