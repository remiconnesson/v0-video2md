import { ApifyClient } from "apify-client";
import { fetch } from "workflow";

import { generateTranscriptToBook } from "@/ai/transcript-to-book";
import type { TranscriptToBook } from "@/ai/transcript-to-book-schema";
import { db } from "@/db";
import {
  channels,
  scrapTranscriptV1,
  videoBookContent,
  videos,
} from "@/db/schema";

interface TranscriptSegment {
  start: number;
  end: number;
  text: string;
}

interface TranscriptResult {
  id: string;
  url: string;
  title: string;
  date?: string;
  channelId: string;
  channelName?: string;
  description?: string;
  numberOfSubscribers?: number;
  viewCount?: number;
  likes?: number;
  duration?: string;
  isAutoGenerated?: boolean;
  thumbnailUrl?: string;
  transcript?: TranscriptSegment[];
}

const parseDuration = (value?: string): number | null => {
  if (!value) return null;

  const parts = value.trim().split(":");
  if (parts.length !== 2 && parts.length !== 3) return null;

  const normalized = parts.map((part) => {
    const numericValue = Number(part);
    if (!Number.isFinite(numericValue) || numericValue < 0) return null;

    const floored = Math.floor(numericValue);
    return Number.isInteger(floored) ? floored : null;
  });

  if (normalized.some((part) => part === null)) return null;

  const [hoursOrMinutes, minutesOrSeconds, seconds] = normalized as number[];

  if (parts.length === 2) {
    return hoursOrMinutes * 60 + minutesOrSeconds;
  }

  return hoursOrMinutes * 3600 + minutesOrSeconds * 60 + seconds;
};

const formatTimestamp = (seconds: number): string => {
  const hours = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);

  if (hours > 0) {
    return `${hours}:${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
  }
  return `${mins}:${secs.toString().padStart(2, "0")}`;
};

const formatTranscriptString = (segments: TranscriptSegment[]): string =>
  segments.map((segment) => `[${formatTimestamp(segment.start)}] ${segment.text}`).join("\n");

export async function fetchAndStoreTranscriptWorkflow(videoId: string) {
  "use workflow";

  const apifyResult = await stepFetchFromApify(videoId);

  if (!apifyResult) {
    throw new Error(`Apify returned no results for video ID: ${videoId}`);
  }

  await stepSaveToDb(apifyResult);

  let bookContent: TranscriptToBook | null = null;

  if (apifyResult.transcript && apifyResult.transcript.length > 0) {
    bookContent = await stepGenerateBookContent({
      transcript: apifyResult.transcript,
      title: apifyResult.title,
      description: apifyResult.description,
      channelName: apifyResult.channelName,
    });

    if (bookContent) {
      await stepSaveBookContent(apifyResult.id, bookContent);
    }
  }

  return {
    success: true,
    videoId: apifyResult.id,
    title: apifyResult.title,
    hasBookContent: bookContent !== null,
  };
}

async function stepFetchFromApify(videoId: string) {
  "use step";

  if (!process.env.APIFY_API_TOKEN) {
    throw new Error("APIFY_API_TOKEN is not defined");
  }

  const client = new ApifyClient({ token: process.env.APIFY_API_TOKEN });
  const run = await client.actor("Uwpce1RSXlrzF6WBA").call({
    youtube_url: `https://www.youtube.com/watch?v=${videoId}`,
  });

  const { items } = await client.dataset(run.defaultDatasetId).listItems();
  return (items[0] as unknown as TranscriptResult | undefined) ?? null;
}

async function stepSaveToDb(data: TranscriptResult) {
  "use step";

  await db
    .insert(channels)
    .values({
      channelId: data.channelId,
      channelName: data.channelName || "Unknown Channel",
    })
    .onConflictDoUpdate({
      target: channels.channelId,
      set: { channelName: data.channelName },
    });

  await db
    .insert(videos)
    .values({
      videoId: data.id,
      url: data.url,
      title: data.title,
      publishedAt: data.date ? new Date(data.date) : null,
      channelId: data.channelId,
    })
    .onConflictDoUpdate({
      target: videos.videoId,
      set: {
        title: data.title,
        url: data.url,
      },
    });

  await db
    .insert(scrapTranscriptV1)
    .values({
      videoId: data.id,
      channelId: data.channelId,
      description: data.description,
      subscriberCount: data.numberOfSubscribers,
      viewCount: data.viewCount,
      likeCount: data.likes,
      durationSeconds: parseDuration(data.duration),
      isAutoGenerated: data.isAutoGenerated,
      thumbnail: data.thumbnailUrl,
      transcript: data.transcript,
    })
    .onConflictDoUpdate({
      target: scrapTranscriptV1.videoId,
      set: {
        transcript: data.transcript,
        viewCount: data.viewCount,
        likeCount: data.likes,
      },
    });
}

async function stepGenerateBookContent(input: {
  transcript: TranscriptSegment[];
  title: string;
  description?: string;
  channelName?: string;
}): Promise<TranscriptToBook> {
  "use step";

  globalThis.fetch = fetch;

  const transcriptString = formatTranscriptString(input.transcript);

  return generateTranscriptToBook({
    transcriptString,
    title: input.title,
    description: input.description,
    channelName: input.channelName,
  });
}

async function stepSaveBookContent(videoId: string, content: TranscriptToBook) {
  "use step";

  await db
    .insert(videoBookContent)
    .values({
      videoId,
      videoSummary: content.videoSummary,
      chapters: content.chapters,
    })
    .onConflictDoUpdate({
      target: videoBookContent.videoId,
      set: {
        videoSummary: content.videoSummary,
        chapters: content.chapters,
        updatedAt: new Date(),
      },
    });
}
