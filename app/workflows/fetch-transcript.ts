import { ApifyClient } from "apify-client";
import { eq } from "drizzle-orm";
import { getWritable } from "workflow";
import { z } from "zod";
import { db } from "@/db";
import {
  saveTranscriptToDb,
  type TranscriptResult,
} from "@/db/save-transcript";
import { channels, scrapTranscriptV1, videos } from "@/db/schema";

// ============================================================================
// Zod schema for validating Apify API response (snake_case as returned by API)
// ============================================================================

const TranscriptSegmentSchema = z.object({
  start: z.number(),
  end: z.number(),
  text: z.string(),
});

const ApifyTranscriptResponseSchema = z.object({
  video_id: z.string(),
  url: z.string(),
  title: z.string(),
  published_at: z.string(),
  channel_id: z.string(),
  channel_name: z.string(),
  description: z.string(),
  subscriber_count: z.number(),
  view_count: z.number(),
  like_count: z.number(),
  duration_seconds: z.number(),
  is_auto_generated: z.boolean(),
  thumbnail: z.string(),
  transcript: z.array(TranscriptSegmentSchema),
});

// ============================================================================
// Transform snake_case API response to camelCase internal format
// ============================================================================

function transformApifyResponse(
  data: z.infer<typeof ApifyTranscriptResponseSchema>,
): TranscriptResult {
  return {
    id: data.video_id,
    url: data.url,
    title: data.title,
    date: data.published_at,
    channelId: data.channel_id,
    channelName: data.channel_name,
    description: data.description,
    numberOfSubscribers: data.subscriber_count,
    viewCount: data.view_count,
    likes: data.like_count,
    duration: formatDurationFromSeconds(data.duration_seconds),
    isAutoGenerated: data.is_auto_generated,
    thumbnailUrl: data.thumbnail,
    transcript: data.transcript,
  };
}

// Convert seconds to duration string (e.g., "50:20" or "1:23:45")
function formatDurationFromSeconds(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);

  if (hours > 0) {
    return `${hours}:${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
  }
  return `${mins}:${secs.toString().padStart(2, "0")}`;
}

// ============================================================================
// Stream Event Types
// ============================================================================

export type TranscriptStreamEvent =
  | { type: "progress"; progress: number; message: string }
  | { type: "complete"; video: { title: string; channelName: string } }
  | { type: "error"; error: string };

// ============================================================================
// Step: Emit progress
// ============================================================================

async function emitProgress(progress: number, message: string) {
  "use step";

  const writable = getWritable<TranscriptStreamEvent>();
  const writer = writable.getWriter();
  await writer.write({ type: "progress", progress, message });
  writer.releaseLock();
}

// ============================================================================
// Step: Emit completion
// ============================================================================

async function emitComplete(video: { title: string; channelName: string }) {
  "use step";

  const writable = getWritable<TranscriptStreamEvent>();
  const writer = writable.getWriter();
  await writer.write({ type: "complete", video });
  writer.releaseLock();
  await writable.close();
}

// ============================================================================
// Step: Emit error
// ============================================================================

async function emitError(error: string) {
  "use step";

  const writable = getWritable<TranscriptStreamEvent>();
  const writer = writable.getWriter();
  await writer.write({ type: "error", error });
  writer.releaseLock();
  await writable.close();
}

// ============================================================================
// Step: Check DB for existing transcript
// ============================================================================

async function stepCheckDbForTranscript(
  videoId: string,
): Promise<TranscriptResult | null> {
  "use step";

  const result = await db
    .select({
      videoId: scrapTranscriptV1.videoId,
      url: videos.url,
      title: videos.title,
      publishedAt: videos.publishedAt,
      channelId: channels.channelId,
      channelName: channels.channelName,
      description: scrapTranscriptV1.description,
      subscriberCount: scrapTranscriptV1.subscriberCount,
      viewCount: scrapTranscriptV1.viewCount,
      likeCount: scrapTranscriptV1.likeCount,
      durationSeconds: scrapTranscriptV1.durationSeconds,
      isAutoGenerated: scrapTranscriptV1.isAutoGenerated,
      thumbnail: scrapTranscriptV1.thumbnail,
      transcript: scrapTranscriptV1.transcript,
    })
    .from(scrapTranscriptV1)
    .innerJoin(videos, eq(scrapTranscriptV1.videoId, videos.videoId))
    .innerJoin(channels, eq(scrapTranscriptV1.channelId, channels.channelId))
    .where(eq(scrapTranscriptV1.videoId, videoId))
    .limit(1);

  if (result.length === 0 || !result[0]) {
    return null;
  }

  const data = result[0];

  // Validate transcript data with Zod
  if (!data.transcript || !Array.isArray(data.transcript)) {
    return null;
  }

  const transcriptParseResult = z
    .array(TranscriptSegmentSchema)
    .safeParse(data.transcript);

  if (!transcriptParseResult.success) {
    console.error("[DB] Transcript validation failed for video:", data.videoId);
    console.error(
      "[DB] Validation errors:",
      JSON.stringify(transcriptParseResult.error.format(), null, 2),
    );
    return null;
  }

  // Format duration from seconds to string
  const duration =
    data.durationSeconds !== null
      ? formatDurationFromSeconds(data.durationSeconds)
      : "0:00";

  return {
    id: data.videoId,
    url: data.url,
    title: data.title,
    date: data.publishedAt ? data.publishedAt.toISOString() : "",
    channelId: data.channelId,
    channelName: data.channelName,
    description: data.description ?? "",
    numberOfSubscribers: data.subscriberCount ?? 0,
    viewCount: data.viewCount ?? 0,
    likes: data.likeCount ?? 0,
    duration,
    isAutoGenerated: data.isAutoGenerated ?? false,
    thumbnailUrl: data.thumbnail ?? "",
    transcript: transcriptParseResult.data,
  };
}

// ============================================================================
// Step: Fetch from Apify
// ============================================================================

async function stepFetchFromApify(
  videoId: string,
): Promise<TranscriptResult | null> {
  "use step";

  if (!process.env.APIFY_API_TOKEN) {
    throw new Error("APIFY_API_TOKEN is not defined");
  }

  const client = new ApifyClient({ token: process.env.APIFY_API_TOKEN });
  const run = await client.actor("Uwpce1RSXlrzF6WBA").call({
    youtube_url: `https://www.youtube.com/watch?v=${videoId}`,
  });

  const { items } = await client.dataset(run.defaultDatasetId).listItems();
  const rawResult = items[0];

  if (!rawResult) {
    return null;
  }

  // Validate the API response with Zod
  const parseResult = ApifyTranscriptResponseSchema.safeParse(rawResult);

  if (!parseResult.success) {
    console.error(
      "[Apify] Validation failed. Raw response keys:",
      Object.keys(rawResult),
    );
    console.error(
      "[Apify] Validation errors:",
      JSON.stringify(parseResult.error.format(), null, 2),
    );
    throw new Error(
      `Invalid Apify response: ${parseResult.error.issues.map((i) => `${i.path.join(".")}: ${i.message}`).join(", ")}`,
    );
  }

  // Transform snake_case API response to camelCase
  return transformApifyResponse(parseResult.data);
}

// ============================================================================
// Step: Save to database
// ============================================================================

async function stepSaveToDb(data: TranscriptResult) {
  "use step";

  await saveTranscriptToDb(data);
}

// ============================================================================
// Main Workflow
// ============================================================================

export async function fetchTranscriptWorkflow(videoId: string) {
  "use workflow";

  try {
    // Step 1: Check if we already have the transcript in the database
    await emitProgress(10, "Checking database for existing transcript...");

    const cachedResult = await stepCheckDbForTranscript(videoId);

    let transcriptData: TranscriptResult;

    if (cachedResult) {
      await emitProgress(
        50,
        "Transcript found in database, skipping API call...",
      );
      transcriptData = cachedResult;
    } else {
      // Step 2: Fetch from Apify
      await emitProgress(20, "Fetching transcript from YouTube...");

      const fetchedResult = await stepFetchFromApify(videoId);

      if (!fetchedResult) {
        await emitError(`No results found for video ID: ${videoId}`);
        throw new Error(`Apify returned no results for video ID: ${videoId}`);
      }

      // Step 3: Save to database
      await emitProgress(80, "Saving video data to database...");
      await stepSaveToDb(fetchedResult);

      transcriptData = fetchedResult;
    }

    // Step 4: Complete
    await emitComplete({
      title: transcriptData.title,
      channelName: transcriptData.channelName,
    });

    return {
      success: true,
      videoId: transcriptData.id,
      title: transcriptData.title,
    };
  } catch (error) {
    const errorMessage =
      error instanceof Error ? error.message : "Unknown error occurred";
    await emitError(errorMessage);
    throw error;
  }
}
